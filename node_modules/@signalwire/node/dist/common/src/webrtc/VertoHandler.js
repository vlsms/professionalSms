"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../util/logger"));
const Call_1 = __importDefault(require("./Call"));
const helpers_1 = require("./helpers");
const Verto_1 = require("../messages/Verto");
const constants_1 = require("../util/constants");
const constants_2 = require("./constants");
const Handler_1 = require("../services/Handler");
const constants_3 = require("./constants");
const LayoutHandler_1 = require("./LayoutHandler");
class VertoHandler {
    constructor(session) {
        this.session = session;
    }
    _ack(id, method) {
        const msg = new Verto_1.Result(id, method);
        if (this.nodeId) {
            msg.targetNodeId = this.nodeId;
        }
        this.session.execute(msg);
    }
    handleMessage(msg) {
        const { session } = this;
        const { id, method, params } = msg;
        const { callID, eventChannel, eventType } = params;
        const attach = method === constants_2.VertoMethod.Attach;
        if (eventType === 'channelPvtData') {
            return this._handlePvtEvent(params.pvtData);
        }
        if (callID && session.calls.hasOwnProperty(callID)) {
            if (attach) {
                session.calls[callID].hangup({}, false);
            }
            else {
                session.calls[callID].handleMessage(msg);
                this._ack(id, method);
                return;
            }
        }
        const _buildCall = () => {
            const call = new Call_1.default(session, {
                id: callID,
                remoteSdp: params.sdp,
                destinationNumber: params.callee_id_number,
                remoteCallerName: params.caller_id_name,
                remoteCallerNumber: params.caller_id_number,
                callerName: params.callee_id_name,
                callerNumber: params.callee_id_number,
                attach
            });
            call.nodeId = this.nodeId;
            return call;
        };
        switch (method) {
            case constants_2.VertoMethod.Punt:
                session.disconnect();
                break;
            case constants_2.VertoMethod.Invite: {
                const call = _buildCall();
                call.setState(constants_3.State.Ringing);
                this._ack(id, method);
                break;
            }
            case constants_2.VertoMethod.Attach: {
                const call = _buildCall();
                if (this.session.autoRecoverCalls) {
                    call.answer();
                }
                else {
                    call.setState(constants_3.State.Recovering);
                }
                call.handleMessage(msg);
                break;
            }
            case constants_2.VertoMethod.Event:
            case 'webrtc.event':
                if (!eventChannel) {
                    logger_1.default.error('Verto received an unknown event:', params);
                    return;
                }
                const protocol = session.relayProtocol;
                const firstValue = eventChannel.split('.')[0];
                if (session._existsSubscription(protocol, eventChannel)) {
                    Handler_1.trigger(protocol, params, eventChannel);
                }
                else if (eventChannel === session.sessionid) {
                    this._handleSessionEvent(params.eventData);
                }
                else if (session._existsSubscription(protocol, firstValue)) {
                    Handler_1.trigger(protocol, params, firstValue);
                }
                else if (session.calls.hasOwnProperty(eventChannel)) {
                    session.calls[eventChannel].handleMessage(msg);
                }
                else {
                    Handler_1.trigger(constants_1.SwEvent.Notification, params, session.uuid);
                }
                break;
            case constants_2.VertoMethod.Info:
                params.type = constants_2.NOTIFICATION_TYPE.generic;
                Handler_1.trigger(constants_1.SwEvent.Notification, params, session.uuid);
                break;
            case constants_2.VertoMethod.ClientReady:
                params.type = constants_2.NOTIFICATION_TYPE.vertoClientReady;
                Handler_1.trigger(constants_1.SwEvent.Notification, params, session.uuid);
                break;
            default:
                logger_1.default.warn('Verto message unknown method:', msg);
        }
    }
    _retrieveCallId(packet, laChannel) {
        const callIds = Object.keys(this.session.calls);
        if (packet.action === 'bootObj') {
            const me = packet.data.find((pr) => callIds.includes(pr[0]));
            if (me instanceof Array) {
                return me[0];
            }
        }
        else {
            return callIds.find((id) => this.session.calls[id].channels.includes(laChannel));
        }
    }
    _handlePvtEvent(pvtData) {
        return __awaiter(this, void 0, void 0, function* () {
            const { session } = this;
            const protocol = session.relayProtocol;
            const { action, laChannel, laName, chatChannel, infoChannel, modChannel, conferenceMemberID, role, callID } = pvtData;
            switch (action) {
                case 'conference-liveArray-join': {
                    const _liveArrayBootstrap = () => {
                        session.vertoBroadcast({ nodeId: this.nodeId, channel: laChannel, data: { liveArray: { command: 'bootstrap', context: laChannel, name: laName } } });
                    };
                    const tmp = {
                        nodeId: this.nodeId,
                        channels: [laChannel],
                        handler: ({ data: packet }) => {
                            const id = callID || this._retrieveCallId(packet, laChannel);
                            if (id && session.calls.hasOwnProperty(id)) {
                                const call = session.calls[id];
                                call._addChannel(laChannel);
                                call.extension = laName;
                                call.handleConferenceUpdate(packet, pvtData)
                                    .then(error => {
                                    if (error === 'INVALID_PACKET') {
                                        _liveArrayBootstrap();
                                    }
                                });
                            }
                        }
                    };
                    const result = yield session.vertoSubscribe(tmp)
                        .catch(error => {
                        logger_1.default.error('liveArray subscription error:', error);
                    });
                    if (helpers_1.checkSubscribeResponse(result, laChannel)) {
                        _liveArrayBootstrap();
                    }
                    break;
                }
                case 'conference-liveArray-part': {
                    let call = null;
                    if (laChannel && session._existsSubscription(protocol, laChannel)) {
                        const { callId = null } = session.subscriptions[protocol][laChannel];
                        call = session.calls[callId] || null;
                        if (callId !== null) {
                            const notification = { type: constants_2.NOTIFICATION_TYPE.conferenceUpdate, action: constants_3.ConferenceAction.Leave, conferenceName: laName, participantId: Number(conferenceMemberID), role };
                            if (!Handler_1.trigger(constants_1.SwEvent.Notification, notification, callId, false)) {
                                Handler_1.trigger(constants_1.SwEvent.Notification, notification, session.uuid);
                            }
                            if (call === null) {
                                Handler_1.deRegister(constants_1.SwEvent.Notification, null, callId);
                            }
                        }
                    }
                    const channels = [laChannel, chatChannel, infoChannel, modChannel];
                    session.vertoUnsubscribe({ nodeId: this.nodeId, channels })
                        .then(({ unsubscribedChannels = [] }) => {
                        if (call) {
                            call.channels = call.channels.filter(c => !unsubscribedChannels.includes(c));
                        }
                    })
                        .catch(error => {
                        logger_1.default.error('liveArray unsubscribe error:', error);
                    });
                    break;
                }
            }
        });
    }
    _handleSessionEvent(eventData) {
        switch (eventData.contentType) {
            case 'layout-info':
            case 'layer-info':
                LayoutHandler_1.MCULayoutEventHandler(this.session, eventData);
                break;
            case 'logo-info': {
                const notification = { type: constants_2.NOTIFICATION_TYPE.conferenceUpdate, action: constants_3.ConferenceAction.LogoInfo, logo: eventData.logoURL };
                Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.session.uuid);
                break;
            }
        }
    }
}
exports.default = VertoHandler;
