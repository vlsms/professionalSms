"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../util/logger"));
const WebRTC = __importStar(require("../util/webrtc"));
const helpers_1 = require("../util/helpers");
const constants_1 = require("./constants");
const getUserMedia = (constraints) => __awaiter(void 0, void 0, void 0, function* () {
    logger_1.default.info('RTCService.getUserMedia', constraints);
    const { audio, video } = constraints;
    if (!audio && !video) {
        return null;
    }
    try {
        return yield WebRTC.getUserMedia(constraints);
    }
    catch (error) {
        logger_1.default.error('getUserMedia error: ', error);
        throw error;
    }
});
exports.getUserMedia = getUserMedia;
const _constraintsByKind = (kind = null) => {
    return {
        audio: !kind || kind === constants_1.DeviceType.AudioIn,
        video: !kind || kind === constants_1.DeviceType.Video
    };
};
const getDevices = (kind = null, fullList = false) => __awaiter(void 0, void 0, void 0, function* () {
    let devices = yield WebRTC.enumerateDevices().catch(error => []);
    if (kind) {
        devices = devices.filter((d) => d.kind === kind);
    }
    const valid = devices.length && devices.every((d) => (d.deviceId && d.label));
    if (!valid) {
        const stream = yield WebRTC.getUserMedia(_constraintsByKind(kind));
        WebRTC.stopStream(stream);
        return getDevices(kind);
    }
    if (fullList === true) {
        return devices;
    }
    const found = [];
    devices = devices.filter(({ kind, groupId }) => {
        if (!groupId) {
            return true;
        }
        const key = `${kind}-${groupId}`;
        if (!found.includes(key)) {
            found.push(key);
            return true;
        }
        return false;
    });
    return devices;
});
exports.getDevices = getDevices;
const resolutionList = [[320, 240], [640, 360], [640, 480], [1280, 720], [1920, 1080]];
const scanResolutions = (deviceId) => __awaiter(void 0, void 0, void 0, function* () {
    const supported = [];
    const stream = yield getUserMedia({ video: { deviceId: { exact: deviceId } } });
    const videoTrack = stream.getVideoTracks()[0];
    for (let i = 0; i < resolutionList.length; i++) {
        const [width, height] = resolutionList[i];
        const success = yield videoTrack.applyConstraints({ width: { exact: width }, height: { exact: height } })
            .then(() => true)
            .catch(() => false);
        if (success) {
            supported.push({ resolution: `${width}x${height}`, width, height });
        }
    }
    WebRTC.stopStream(stream);
    return supported;
});
exports.scanResolutions = scanResolutions;
const getMediaConstraints = (options) => __awaiter(void 0, void 0, void 0, function* () {
    let { audio = true, micId } = options;
    const { micLabel = '' } = options;
    if (micId) {
        micId = yield assureDeviceId(micId, micLabel, constants_1.DeviceType.AudioIn).catch(error => null);
        if (micId) {
            if (typeof audio === 'boolean') {
                audio = {};
            }
            audio.deviceId = { exact: micId };
        }
    }
    let { video = false, camId } = options;
    const { camLabel = '' } = options;
    if (camId) {
        camId = yield assureDeviceId(camId, camLabel, constants_1.DeviceType.Video).catch(error => null);
        if (camId) {
            if (typeof video === 'boolean') {
                video = {};
            }
            video.deviceId = { exact: camId };
        }
    }
    return { audio, video };
});
exports.getMediaConstraints = getMediaConstraints;
const assureDeviceId = (id, label, kind) => __awaiter(void 0, void 0, void 0, function* () {
    const devices = yield getDevices(kind, true);
    for (let i = 0; i < devices.length; i++) {
        const { deviceId, label: deviceLabel } = devices[i];
        if (id === deviceId || label === deviceLabel) {
            return deviceId;
        }
    }
    return null;
});
exports.assureDeviceId = assureDeviceId;
const removeUnsupportedConstraints = (constraints) => {
    const supported = WebRTC.getSupportedConstraints();
    Object.keys(constraints).map(key => {
        if (!supported.hasOwnProperty(key) || constraints[key] === null || constraints[key] === undefined) {
            delete constraints[key];
        }
    });
};
exports.removeUnsupportedConstraints = removeUnsupportedConstraints;
const checkDeviceIdConstraints = (id, label, kind, constraints) => __awaiter(void 0, void 0, void 0, function* () {
    const { deviceId } = constraints;
    if (!helpers_1.isDefined(deviceId) && (id || label)) {
        const deviceId = yield assureDeviceId(id, label, kind).catch(error => null);
        if (deviceId) {
            constraints.deviceId = { exact: deviceId };
        }
    }
    return constraints;
});
exports.checkDeviceIdConstraints = checkDeviceIdConstraints;
const sdpStereoHack = (sdp) => {
    const endOfLine = '\r\n';
    const sdpLines = sdp.split(endOfLine);
    const opusIndex = sdpLines.findIndex(s => /^a=rtpmap/.test(s) && /opus\/48000/.test(s));
    if (opusIndex < 0) {
        return sdp;
    }
    const getCodecPayloadType = (line) => {
        const pattern = new RegExp('a=rtpmap:(\\d+) \\w+\\/\\d+');
        const result = line.match(pattern);
        return result && result.length == 2 ? result[1] : null;
    };
    const opusPayload = getCodecPayloadType(sdpLines[opusIndex]);
    const pattern = new RegExp(`a=fmtp:${opusPayload}`);
    const fmtpLineIndex = sdpLines.findIndex(s => pattern.test(s));
    if (fmtpLineIndex >= 0) {
        if (!/stereo=1;/.test(sdpLines[fmtpLineIndex])) {
            sdpLines[fmtpLineIndex] += '; stereo=1; sprop-stereo=1';
        }
    }
    else {
        sdpLines[opusIndex] += `${endOfLine}a=fmtp:${opusPayload} stereo=1; sprop-stereo=1`;
    }
    return sdpLines.join(endOfLine);
};
exports.sdpStereoHack = sdpStereoHack;
const _isAudioLine = (line) => /^m=audio/.test(line);
const _isVideoLine = (line) => /^m=video/.test(line);
const sdpMediaOrderHack = (answer, localOffer) => {
    const endOfLine = '\r\n';
    const offerLines = localOffer.split(endOfLine);
    const offerAudioIndex = offerLines.findIndex(_isAudioLine);
    const offerVideoIndex = offerLines.findIndex(_isVideoLine);
    if (offerAudioIndex < offerVideoIndex) {
        return answer;
    }
    const answerLines = answer.split(endOfLine);
    const answerAudioIndex = answerLines.findIndex(_isAudioLine);
    const answerVideoIndex = answerLines.findIndex(_isVideoLine);
    const audioLines = answerLines.slice(answerAudioIndex, answerVideoIndex);
    const videoLines = answerLines.slice(answerVideoIndex, (answerLines.length - 1));
    const beginLines = answerLines.slice(0, answerAudioIndex);
    return [...beginLines, ...videoLines, ...audioLines, ''].join(endOfLine);
};
exports.sdpMediaOrderHack = sdpMediaOrderHack;
const checkSubscribeResponse = (response, channel) => {
    if (!response) {
        return false;
    }
    const { subscribed, alreadySubscribed } = destructSubscribeResponse(response);
    return subscribed.includes(channel) || alreadySubscribed.includes(channel);
};
exports.checkSubscribeResponse = checkSubscribeResponse;
const destructSubscribeResponse = (response) => {
    const tmp = {
        subscribed: [],
        alreadySubscribed: [],
        unauthorized: [],
        unsubscribed: [],
        notSubscribed: []
    };
    Object.keys(tmp).forEach(k => { tmp[k] = response[`${k}Channels`] || []; });
    return tmp;
};
exports.destructSubscribeResponse = destructSubscribeResponse;
const enableAudioTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'audio', true);
};
exports.enableAudioTracks = enableAudioTracks;
const disableAudioTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'audio', false);
};
exports.disableAudioTracks = disableAudioTracks;
const toggleAudioTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'audio', null);
};
exports.toggleAudioTracks = toggleAudioTracks;
const enableVideoTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'video', true);
};
exports.enableVideoTracks = enableVideoTracks;
const disableVideoTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'video', false);
};
exports.disableVideoTracks = disableVideoTracks;
const toggleVideoTracks = (stream) => {
    _updateMediaStreamTracks(stream, 'video', null);
};
exports.toggleVideoTracks = toggleVideoTracks;
const _updateMediaStreamTracks = (stream, kind = null, enabled = null) => {
    if (!WebRTC.streamIsValid(stream)) {
        return null;
    }
    let tracks = [];
    switch (kind) {
        case 'audio':
            tracks = stream.getAudioTracks();
            break;
        case 'video':
            tracks = stream.getVideoTracks();
            break;
        default:
            tracks = stream.getTracks();
            break;
    }
    tracks.forEach((track) => {
        switch (enabled) {
            case 'on':
            case true:
                track.enabled = true;
                break;
            case 'off':
            case false:
                track.enabled = false;
                break;
            default:
                track.enabled = !track.enabled;
                break;
        }
    });
};
const sdpBitrateHack = (sdp, max, min, start) => {
    const endOfLine = '\r\n';
    const lines = sdp.split(endOfLine);
    lines.forEach((line, i) => {
        if (/^a=fmtp:\d*/.test(line)) {
            lines[i] += `;x-google-max-bitrate=${max};x-google-min-bitrate=${min};x-google-start-bitrate=${start}`;
        }
        else if (/^a=mid:(1|video)/.test(line)) {
            lines[i] += `\r\nb=AS:${max}`;
        }
    });
    return lines.join(endOfLine);
};
exports.sdpBitrateHack = sdpBitrateHack;
