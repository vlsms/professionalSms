"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../util/logger"));
const helpers_1 = require("./helpers");
const constants_1 = require("../util/constants");
const constants_2 = require("./constants");
const webrtc_1 = require("../util/webrtc");
const helpers_2 = require("../util/helpers");
const Handler_1 = require("../services/Handler");
class Peer {
    constructor(type, options) {
        this.type = type;
        this.options = options;
        this.onSdpReadyTwice = null;
        this._negotiating = false;
        logger_1.default.info('New Peer with type:', this.type, 'Options:', this.options);
        this._constraints = { offerToReceiveAudio: true, offerToReceiveVideo: true };
        this._sdpReady = this._sdpReady.bind(this);
        this._init();
    }
    startNegotiation() {
        this._negotiating = true;
        if (this._isOffer()) {
            this._createOffer();
        }
        else {
            this._createAnswer();
        }
    }
    _init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.instance = webrtc_1.RTCPeerConnection(this._config());
            this.instance.onsignalingstatechange = event => {
                switch (this.instance.signalingState) {
                    case 'stable':
                        this._negotiating = false;
                        break;
                    case 'closed':
                        this.instance = null;
                        break;
                    default:
                        this._negotiating = true;
                }
            };
            this.instance.onnegotiationneeded = event => {
                if (this._negotiating) {
                    logger_1.default.debug('Skip twice onnegotiationneeded..');
                    return;
                }
                this.startNegotiation();
            };
            this.options.localStream = yield this._retrieveLocalStream()
                .catch(error => {
                Handler_1.trigger(constants_1.SwEvent.MediaError, error, this.options.id);
                return null;
            });
            const { localElement, localStream = null, screenShare = false } = this.options;
            if (webrtc_1.streamIsValid(localStream)) {
                if (typeof this.instance.addTrack === 'function') {
                    localStream.getTracks().forEach(t => this.instance.addTrack(t, localStream));
                }
                else {
                    this.instance.addStream(localStream);
                }
                if (screenShare !== true) {
                    webrtc_1.muteMediaElement(localElement);
                    webrtc_1.attachMediaStream(localElement, localStream);
                }
            }
            else if (localStream === null) {
                this.startNegotiation();
            }
        });
    }
    _createOffer() {
        if (!this._isOffer()) {
            return;
        }
        this.instance.createOffer(this._constraints)
            .then(this._setLocalDescription.bind(this))
            .then(this._sdpReady)
            .catch(error => logger_1.default.error('Peer _createOffer error:', error));
    }
    _createAnswer() {
        if (!this._isAnswer()) {
            return;
        }
        const { remoteSdp, useStereo } = this.options;
        const sdp = useStereo ? helpers_1.sdpStereoHack(remoteSdp) : remoteSdp;
        const sessionDescr = webrtc_1.sdpToJsonHack({ sdp, type: constants_2.PeerType.Offer });
        this.instance.setRemoteDescription(sessionDescr)
            .then(() => this.instance.createAnswer())
            .then(this._setLocalDescription.bind(this))
            .then(this._sdpReady)
            .catch(error => logger_1.default.error('Peer _createAnswer error:', error));
    }
    _setLocalDescription(sessionDescription) {
        const { useStereo, googleMaxBitrate, googleMinBitrate, googleStartBitrate } = this.options;
        if (useStereo) {
            sessionDescription.sdp = helpers_1.sdpStereoHack(sessionDescription.sdp);
        }
        if (googleMaxBitrate && googleMinBitrate && googleStartBitrate) {
            sessionDescription.sdp = helpers_1.sdpBitrateHack(sessionDescription.sdp, googleMaxBitrate, googleMinBitrate, googleStartBitrate);
        }
        return this.instance.setLocalDescription(sessionDescription);
    }
    _sdpReady() {
        if (helpers_2.isFunction(this.onSdpReadyTwice)) {
            this.onSdpReadyTwice(this.instance.localDescription);
        }
    }
    _retrieveLocalStream() {
        return __awaiter(this, void 0, void 0, function* () {
            if (webrtc_1.streamIsValid(this.options.localStream)) {
                return this.options.localStream;
            }
            const constraints = yield helpers_1.getMediaConstraints(this.options);
            return helpers_1.getUserMedia(constraints);
        });
    }
    _isOffer() {
        return this.type === constants_2.PeerType.Offer;
    }
    _isAnswer() {
        return this.type === constants_2.PeerType.Answer;
    }
    _config() {
        const { iceServers = [] } = this.options;
        const config = { sdpSemantics: 'plan-b', bundlePolicy: 'max-compat', iceServers };
        logger_1.default.info('RTC config', config);
        return config;
    }
}
exports.default = Peer;
