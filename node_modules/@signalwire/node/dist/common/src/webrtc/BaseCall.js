"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const logger_1 = __importDefault(require("../util/logger"));
const Verto_1 = require("../messages/Verto");
const Peer_1 = __importDefault(require("./Peer"));
const constants_1 = require("../util/constants");
const constants_2 = require("./constants");
const Handler_1 = require("../services/Handler");
const helpers_1 = require("./helpers");
const helpers_2 = require("../util/helpers");
const webrtc_1 = require("../util/webrtc");
const LayoutHandler_1 = require("./LayoutHandler");
class BaseCall {
    constructor(session, opts) {
        this.session = session;
        this.id = '';
        this.state = constants_2.State[constants_2.State.New];
        this.prevState = '';
        this.channels = [];
        this.role = constants_2.Role.Participant;
        this.extension = null;
        this._state = constants_2.State.New;
        this._prevState = constants_2.State.New;
        this.gotAnswer = false;
        this.gotEarly = false;
        this._lastSerno = 0;
        this._targetNodeId = null;
        this._iceTimeout = null;
        this._iceDone = false;
        this._checkConferenceSerno = (serno) => {
            const check = (serno < 0) || (!this._lastSerno || (this._lastSerno && serno === (this._lastSerno + 1)));
            if (check && serno >= 0) {
                this._lastSerno = serno;
            }
            return check;
        };
        const { iceServers, speaker: speakerId, micId, micLabel, camId, camLabel, localElement, remoteElement, mediaConstraints: { audio, video } } = session;
        this.options = Object.assign({}, constants_2.DEFAULT_CALL_OPTIONS, { audio, video, iceServers, localElement, remoteElement, micId, micLabel, camId, camLabel, speakerId }, opts);
        this._onMediaError = this._onMediaError.bind(this);
        this._init();
    }
    get nodeId() {
        return this._targetNodeId;
    }
    set nodeId(what) {
        this._targetNodeId = what;
    }
    get localStream() {
        return this.options.localStream;
    }
    get remoteStream() {
        return this.options.remoteStream;
    }
    get memberChannel() {
        return `conference-member.${this.id}`;
    }
    invite() {
        this.direction = constants_2.Direction.Outbound;
        this.peer = new Peer_1.default(constants_2.PeerType.Offer, this.options);
        this._registerPeerEvents();
    }
    answer() {
        this.direction = constants_2.Direction.Inbound;
        this.peer = new Peer_1.default(constants_2.PeerType.Answer, this.options);
        this._registerPeerEvents();
    }
    hangup(params = {}, execute = true) {
        this.cause = params.cause || 'NORMAL_CLEARING';
        this.causeCode = params.causeCode || 16;
        this.setState(constants_2.State.Hangup);
        const _close = () => {
            this.peer ? this.peer.instance.close() : null;
            this.setState(constants_2.State.Destroy);
        };
        if (execute) {
            const bye = new Verto_1.Bye({ sessid: this.session.sessionid, dialogParams: this.options });
            this._execute(bye)
                .catch(error => logger_1.default.error('verto.bye failed!', error))
                .then(_close.bind(this));
        }
        else {
            _close();
        }
    }
    transfer(destination) {
        const msg = new Verto_1.Modify({ sessid: this.session.sessionid, action: 'transfer', destination, dialogParams: this.options });
        this._execute(msg);
    }
    replace(replaceCallID) {
        const msg = new Verto_1.Modify({ sessid: this.session.sessionid, action: 'replace', replaceCallID, dialogParams: this.options });
        this._execute(msg);
    }
    hold() {
        const msg = new Verto_1.Modify({ sessid: this.session.sessionid, action: 'hold', dialogParams: this.options });
        return this._execute(msg)
            .then(this._handleChangeHoldStateSuccess.bind(this))
            .catch(this._handleChangeHoldStateError.bind(this));
    }
    unhold() {
        const msg = new Verto_1.Modify({ sessid: this.session.sessionid, action: 'unhold', dialogParams: this.options });
        return this._execute(msg)
            .then(this._handleChangeHoldStateSuccess.bind(this))
            .catch(this._handleChangeHoldStateError.bind(this));
    }
    toggleHold() {
        const msg = new Verto_1.Modify({ sessid: this.session.sessionid, action: 'toggleHold', dialogParams: this.options });
        return this._execute(msg)
            .then(this._handleChangeHoldStateSuccess.bind(this))
            .catch(this._handleChangeHoldStateError.bind(this));
    }
    dtmf(dtmf) {
        const msg = new Verto_1.Info({ sessid: this.session.sessionid, dtmf, dialogParams: this.options });
        this._execute(msg);
    }
    message(to, body) {
        const msg = { from: this.session.options.login, to, body };
        const info = new Verto_1.Info({ sessid: this.session.sessionid, msg, dialogParams: this.options });
        this._execute(info);
    }
    muteAudio() {
        helpers_1.disableAudioTracks(this.options.localStream);
    }
    unmuteAudio() {
        helpers_1.enableAudioTracks(this.options.localStream);
    }
    toggleAudioMute() {
        helpers_1.toggleAudioTracks(this.options.localStream);
    }
    setAudioInDevice(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instance } = this.peer;
            const sender = instance.getSenders().find(({ track: { kind } }) => kind === 'audio');
            if (sender) {
                const newStream = yield webrtc_1.getUserMedia({ audio: { deviceId: { exact: deviceId } } });
                const audioTrack = newStream.getAudioTracks()[0];
                sender.replaceTrack(audioTrack);
                this.options.micId = deviceId;
                const { localStream } = this.options;
                localStream.getAudioTracks().forEach(t => t.stop());
                localStream.getVideoTracks().forEach(t => newStream.addTrack(t));
                this.options.localStream = newStream;
            }
        });
    }
    muteVideo() {
        helpers_1.disableVideoTracks(this.options.localStream);
    }
    unmuteVideo() {
        helpers_1.enableVideoTracks(this.options.localStream);
    }
    toggleVideoMute() {
        helpers_1.toggleVideoTracks(this.options.localStream);
    }
    setVideoDevice(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instance } = this.peer;
            const sender = instance.getSenders().find(({ track: { kind } }) => kind === 'video');
            if (sender) {
                const newStream = yield webrtc_1.getUserMedia({ video: { deviceId: { exact: deviceId } } });
                const videoTrack = newStream.getVideoTracks()[0];
                sender.replaceTrack(videoTrack);
                const { localElement, localStream } = this.options;
                webrtc_1.attachMediaStream(localElement, newStream);
                this.options.camId = deviceId;
                localStream.getAudioTracks().forEach(t => newStream.addTrack(t));
                localStream.getVideoTracks().forEach(t => t.stop());
                this.options.localStream = newStream;
            }
        });
    }
    deaf() {
        helpers_1.disableAudioTracks(this.options.remoteStream);
    }
    undeaf() {
        helpers_1.enableAudioTracks(this.options.remoteStream);
    }
    toggleDeaf() {
        helpers_1.toggleAudioTracks(this.options.remoteStream);
    }
    setState(state) {
        this._prevState = this._state;
        this._state = state;
        this.state = constants_2.State[this._state].toLowerCase();
        this.prevState = constants_2.State[this._prevState].toLowerCase();
        logger_1.default.info(`Call ${this.id} state change from ${this.prevState} to ${this.state}`);
        this._dispatchNotification({ type: constants_2.NOTIFICATION_TYPE.callUpdate, call: this });
        switch (state) {
            case constants_2.State.Purge:
                this.hangup({ cause: 'PURGE', causeCode: '01' }, false);
                break;
            case constants_2.State.Active: {
                setTimeout(() => {
                    const { remoteElement, speakerId } = this.options;
                    if (remoteElement && speakerId) {
                        webrtc_1.setMediaElementSinkId(remoteElement, speakerId);
                    }
                }, 0);
                break;
            }
            case constants_2.State.Destroy:
                this._finalize();
                break;
        }
    }
    handleMessage(msg) {
        const { method, params } = msg;
        switch (method) {
            case constants_2.VertoMethod.Answer: {
                this.gotAnswer = true;
                if (this._state >= constants_2.State.Active) {
                    return;
                }
                if (this._state >= constants_2.State.Early) {
                    this.setState(constants_2.State.Active);
                }
                if (!this.gotEarly) {
                    this._onRemoteSdp(params.sdp);
                }
                break;
            }
            case constants_2.VertoMethod.Media: {
                if (this._state >= constants_2.State.Early) {
                    return;
                }
                this.gotEarly = true;
                this._onRemoteSdp(params.sdp);
                break;
            }
            case constants_2.VertoMethod.Display:
            case constants_2.VertoMethod.Attach: {
                const { display_name: displayName, display_number: displayNumber, display_direction } = params;
                this.extension = displayNumber;
                const displayDirection = display_direction === constants_2.Direction.Inbound ? constants_2.Direction.Outbound : constants_2.Direction.Inbound;
                const notification = { type: constants_2.NOTIFICATION_TYPE[method], call: this, displayName, displayNumber, displayDirection };
                if (!Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.id)) {
                    Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.session.uuid);
                }
                break;
            }
            case constants_2.VertoMethod.Info:
            case constants_2.VertoMethod.Event: {
                const notification = Object.assign(Object.assign({}, params), { type: constants_2.NOTIFICATION_TYPE.generic, call: this });
                if (!Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.id)) {
                    Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.session.uuid);
                }
                break;
            }
            case constants_2.VertoMethod.Bye:
                this.hangup(params, false);
                break;
        }
    }
    handleConferenceUpdate(packet, initialPvtData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._checkConferenceSerno(packet.wireSerno) && packet.name !== initialPvtData.laName) {
                logger_1.default.error('ConferenceUpdate invalid wireSerno or packet name:', packet);
                return 'INVALID_PACKET';
            }
            const { action, data, hashKey: callId = String(this._lastSerno), arrIndex: index } = packet;
            switch (action) {
                case 'bootObj': {
                    this._lastSerno = 0;
                    const { chatID, chatChannel, infoChannel, modChannel, laName, conferenceMemberID, role } = initialPvtData;
                    this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.Join, conferenceName: laName, participantId: Number(conferenceMemberID), role });
                    if (chatChannel) {
                        yield this._subscribeConferenceChat(chatChannel);
                    }
                    if (infoChannel) {
                        yield this._subscribeConferenceInfo(infoChannel);
                    }
                    if (modChannel && role === constants_2.Role.Moderator) {
                        yield this._subscribeConferenceModerator(modChannel);
                    }
                    const participants = [];
                    for (const i in data) {
                        participants.push(Object.assign({ callId: data[i][0], index: Number(i) }, helpers_2.mutateLiveArrayData(data[i][1])));
                    }
                    this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.Bootstrap, participants });
                    break;
                }
                case 'add': {
                    this._dispatchConferenceUpdate(Object.assign({ action: constants_2.ConferenceAction.Add, callId, index }, helpers_2.mutateLiveArrayData(data)));
                    break;
                }
                case 'modify':
                    this._dispatchConferenceUpdate(Object.assign({ action: constants_2.ConferenceAction.Modify, callId, index }, helpers_2.mutateLiveArrayData(data)));
                    break;
                case 'del':
                    this._dispatchConferenceUpdate(Object.assign({ action: constants_2.ConferenceAction.Delete, callId, index }, helpers_2.mutateLiveArrayData(data)));
                    break;
                case 'clear':
                    this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.Clear });
                    break;
                default:
                    this._dispatchConferenceUpdate({ action, data, callId, index });
                    break;
            }
        });
    }
    _addChannel(channel) {
        if (!this.channels.includes(channel)) {
            this.channels.push(channel);
        }
        const protocol = this.session.relayProtocol;
        if (this.session._existsSubscription(protocol, channel)) {
            this.session.subscriptions[protocol][channel] = Object.assign(Object.assign({}, this.session.subscriptions[protocol][channel]), { callId: this.id });
        }
    }
    _subscribeConferenceChat(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const tmp = {
                nodeId: this.nodeId,
                channels: [channel],
                handler: (params) => {
                    const { direction, from: participantNumber, fromDisplay: participantName, message: messageText, type: messageType } = params.data;
                    this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.ChatMessage, direction, participantNumber, participantName, messageText, messageType, messageId: params.eventSerno });
                }
            };
            const response = yield this.session.vertoSubscribe(tmp)
                .catch(error => {
                logger_1.default.error('ConfChat subscription error:', error);
            });
            if (helpers_1.checkSubscribeResponse(response, channel)) {
                this._addChannel(channel);
                Object.defineProperties(this, {
                    sendChatMessage: {
                        configurable: true,
                        value: (message, type) => {
                            this.session.vertoBroadcast({ nodeId: this.nodeId, channel, data: { action: 'send', message, type } });
                        }
                    }
                });
            }
        });
    }
    _subscribeConferenceInfo(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const tmp = {
                nodeId: this.nodeId,
                channels: [channel],
                handler: (params) => {
                    const { eventData } = params;
                    switch (eventData.contentType) {
                        case 'layout-info':
                            eventData.callID = this.id;
                            LayoutHandler_1.MCULayoutEventHandler(this.session, eventData);
                            break;
                        default:
                            logger_1.default.error('Conference-Info unknown contentType', params);
                    }
                }
            };
            const response = yield this.session.vertoSubscribe(tmp)
                .catch(error => {
                logger_1.default.error('ConfInfo subscription error:', error);
            });
            if (helpers_1.checkSubscribeResponse(response, channel)) {
                this._addChannel(channel);
            }
        });
    }
    _confControl(channel, params = {}) {
        const data = Object.assign({ application: 'conf-control', callID: this.id, value: null }, params);
        this.session.vertoBroadcast({ nodeId: this.nodeId, channel, data });
    }
    _subscribeConferenceModerator(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const _modCommand = (command, memberID = null, value = null) => {
                const id = parseInt(memberID) || null;
                this._confControl(channel, { command, id, value });
            };
            const _videoRequired = () => {
                const { video } = this.options;
                if ((typeof video === 'boolean' && !video) || (typeof video === 'object' && helpers_2.objEmpty(video))) {
                    throw `Conference ${this.id} has no video!`;
                }
            };
            const tmp = {
                nodeId: this.nodeId,
                channels: [channel],
                handler: (params) => {
                    const { data } = params;
                    switch (data['conf-command']) {
                        case 'list-videoLayouts':
                            if (data.responseData) {
                                const tmp = JSON.stringify(data.responseData).replace(/IDS"/g, 'Ids"');
                                this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.LayoutList, layouts: JSON.parse(tmp) });
                            }
                            break;
                        default:
                            this._dispatchConferenceUpdate({ action: constants_2.ConferenceAction.ModCmdResponse, command: data['conf-command'], response: data.response });
                    }
                }
            };
            const response = yield this.session.vertoSubscribe(tmp)
                .catch(error => {
                logger_1.default.error('ConfMod subscription error:', error);
            });
            if (helpers_1.checkSubscribeResponse(response, channel)) {
                this.role = constants_2.Role.Moderator;
                this._addChannel(channel);
                Object.defineProperties(this, {
                    listVideoLayouts: {
                        configurable: true,
                        value: () => {
                            _modCommand('list-videoLayouts');
                        }
                    },
                    playMedia: {
                        configurable: true,
                        value: (file) => {
                            _modCommand('play', null, file);
                        }
                    },
                    stopMedia: {
                        configurable: true,
                        value: () => {
                            _modCommand('stop', null, 'all');
                        }
                    },
                    deaf: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('deaf', memberID);
                        }
                    },
                    undeaf: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('undeaf', memberID);
                        }
                    },
                    startRecord: {
                        configurable: true,
                        value: (file) => {
                            _modCommand('recording', null, ['start', file]);
                        }
                    },
                    stopRecord: {
                        configurable: true,
                        value: () => {
                            _modCommand('recording', null, ['stop', 'all']);
                        }
                    },
                    snapshot: {
                        configurable: true,
                        value: (file) => {
                            _videoRequired();
                            _modCommand('vid-write-png', null, file);
                        }
                    },
                    setVideoLayout: {
                        configurable: true,
                        value: (layout, canvasID) => {
                            _videoRequired();
                            const value = canvasID ? [layout, canvasID] : layout;
                            _modCommand('vid-layout', null, value);
                        }
                    },
                    kick: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('kick', memberID);
                        }
                    },
                    muteMic: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('tmute', memberID);
                        }
                    },
                    muteVideo: {
                        configurable: true,
                        value: (memberID) => {
                            _videoRequired();
                            _modCommand('tvmute', memberID);
                        }
                    },
                    presenter: {
                        configurable: true,
                        value: (memberID) => {
                            _videoRequired();
                            _modCommand('vid-res-id', memberID, 'presenter');
                        }
                    },
                    videoFloor: {
                        configurable: true,
                        value: (memberID) => {
                            _videoRequired();
                            _modCommand('vid-floor', memberID, 'force');
                        }
                    },
                    banner: {
                        configurable: true,
                        value: (memberID, text) => {
                            _videoRequired();
                            _modCommand('vid-banner', memberID, encodeURI(text));
                        }
                    },
                    volumeDown: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('volume_out', memberID, 'down');
                        }
                    },
                    volumeUp: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('volume_out', memberID, 'up');
                        }
                    },
                    gainDown: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('volume_in', memberID, 'down');
                        }
                    },
                    gainUp: {
                        configurable: true,
                        value: (memberID) => {
                            _modCommand('volume_in', memberID, 'up');
                        }
                    },
                    transfer: {
                        configurable: true,
                        value: (memberID, exten) => {
                            _modCommand('transfer', memberID, exten);
                        }
                    }
                });
            }
        });
    }
    _handleChangeHoldStateSuccess(response) {
        response.holdState === 'active' ? this.setState(constants_2.State.Active) : this.setState(constants_2.State.Held);
        return true;
    }
    _handleChangeHoldStateError(error) {
        logger_1.default.error(`Failed to ${error.action} on call ${this.id}`);
        return false;
    }
    _onRemoteSdp(remoteSdp) {
        let sdp = helpers_1.sdpMediaOrderHack(remoteSdp, this.peer.instance.localDescription.sdp);
        if (this.options.useStereo) {
            sdp = helpers_1.sdpStereoHack(sdp);
        }
        const sessionDescr = webrtc_1.sdpToJsonHack({ sdp, type: constants_2.PeerType.Answer });
        this.peer.instance.setRemoteDescription(sessionDescr)
            .then(() => {
            if (this.gotEarly) {
                this.setState(constants_2.State.Early);
            }
            if (this.gotAnswer) {
                this.setState(constants_2.State.Active);
            }
        })
            .catch(error => {
            logger_1.default.error('Call setRemoteDescription Error: ', error);
            this.hangup();
        });
    }
    _requestAnotherLocalDescription() {
        if (helpers_2.isFunction(this.peer.onSdpReadyTwice)) {
            Handler_1.trigger(constants_1.SwEvent.Error, new Error('SDP without candidates for the second time!'), this.session.uuid);
            return;
        }
        Object.defineProperty(this.peer, 'onSdpReadyTwice', { value: this._onIceSdp.bind(this) });
        this._iceDone = false;
        this.peer.startNegotiation();
    }
    _onIceSdp(data) {
        if (this._iceTimeout) {
            clearTimeout(this._iceTimeout);
        }
        this._iceTimeout = null;
        this._iceDone = true;
        const { sdp, type } = data;
        if (sdp.indexOf('candidate') === -1) {
            this._requestAnotherLocalDescription();
            return;
        }
        let msg = null;
        const tmpParams = { sessid: this.session.sessionid, sdp, dialogParams: this.options };
        switch (type) {
            case constants_2.PeerType.Offer:
                this.setState(constants_2.State.Requesting);
                msg = new Verto_1.Invite(tmpParams);
                break;
            case constants_2.PeerType.Answer:
                this.setState(constants_2.State.Answering);
                msg = this.options.attach === true ? new Verto_1.Attach(tmpParams) : new Verto_1.Answer(tmpParams);
                break;
            default:
                logger_1.default.error(`${this.id} - Unknown local SDP type:`, data);
                return this.hangup({}, false);
        }
        this._execute(msg)
            .then(response => {
            const { node_id = null } = response;
            this._targetNodeId = node_id;
            type === constants_2.PeerType.Offer ? this.setState(constants_2.State.Trying) : this.setState(constants_2.State.Active);
        })
            .catch(error => {
            logger_1.default.error(`${this.id} - Sending ${type} error:`, error);
            this.hangup();
        });
    }
    _registerPeerEvents() {
        const { instance } = this.peer;
        this._iceDone = false;
        instance.onicecandidate = event => {
            if (this._iceDone) {
                return;
            }
            if (this._iceTimeout === null) {
                this._iceTimeout = setTimeout(() => this._onIceSdp(instance.localDescription), 1000);
            }
            if (event.candidate) {
                logger_1.default.info('IceCandidate:', event.candidate);
            }
            else {
                this._onIceSdp(instance.localDescription);
            }
        };
        instance.addEventListener('track', (event) => {
            this.options.remoteStream = event.streams[0];
            const { remoteElement, remoteStream, screenShare } = this.options;
            if (screenShare === false) {
                webrtc_1.attachMediaStream(remoteElement, remoteStream);
            }
        });
        instance.addEventListener('addstream', (event) => {
            this.options.remoteStream = event.stream;
        });
    }
    _onMediaError(error) {
        this._dispatchNotification({ type: constants_2.NOTIFICATION_TYPE.userMediaError, error });
        this.hangup({}, false);
    }
    _dispatchConferenceUpdate(params) {
        this._dispatchNotification(Object.assign({ type: constants_2.NOTIFICATION_TYPE.conferenceUpdate, call: this }, params));
    }
    _dispatchNotification(notification) {
        if (this.options.screenShare === true) {
            return;
        }
        if (!Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.id, false)) {
            Handler_1.trigger(constants_1.SwEvent.Notification, notification, this.session.uuid);
        }
    }
    _execute(msg) {
        if (this.nodeId) {
            msg.targetNodeId = this.nodeId;
        }
        return this.session.execute(msg);
    }
    _init() {
        const { id, userVariables, remoteCallerNumber, onNotification } = this.options;
        if (!id) {
            this.options.id = uuid_1.v4();
        }
        this.id = this.options.id;
        if (!userVariables || helpers_2.objEmpty(userVariables)) {
            this.options.userVariables = this.session.options.userVariables || {};
        }
        if (!remoteCallerNumber) {
            this.options.remoteCallerNumber = this.options.destinationNumber;
        }
        this.session.calls[this.id] = this;
        Handler_1.register(constants_1.SwEvent.MediaError, this._onMediaError, this.id);
        if (helpers_2.isFunction(onNotification)) {
            Handler_1.register(constants_1.SwEvent.Notification, onNotification.bind(this), this.id);
        }
        this.setState(constants_2.State.New);
        logger_1.default.info('New Call with Options:', this.options);
    }
    _finalize() {
        const { remoteStream, localStream, remoteElement, localElement } = this.options;
        webrtc_1.stopStream(remoteStream);
        webrtc_1.stopStream(localStream);
        if (this.options.screenShare !== true) {
            webrtc_1.detachMediaStream(remoteElement);
            webrtc_1.detachMediaStream(localElement);
        }
        Handler_1.deRegister(constants_1.SwEvent.MediaError, null, this.id);
        this.peer = null;
        this.session.calls[this.id] = null;
        delete this.session.calls[this.id];
    }
}
exports.default = BaseCall;
