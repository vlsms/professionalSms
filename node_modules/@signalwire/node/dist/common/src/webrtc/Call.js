"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../util/logger"));
const BaseCall_1 = __importDefault(require("./BaseCall"));
const webrtc_1 = require("../util/webrtc");
class Call extends BaseCall_1.default {
    constructor() {
        super(...arguments);
        this._statsInterval = null;
    }
    hangup(params = {}, execute = true) {
        if (this.screenShare instanceof Call) {
            this.screenShare.hangup(params, execute);
        }
        super.hangup(params, execute);
    }
    startScreenShare(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const displayStream = yield webrtc_1.getDisplayMedia({ video: true });
            displayStream.getTracks().forEach(t => {
                t.addEventListener('ended', () => {
                    if (this.screenShare) {
                        this.screenShare.hangup();
                    }
                });
            });
            const { remoteCallerName, remoteCallerNumber, callerName, callerNumber } = this.options;
            const options = Object.assign({ screenShare: true, localStream: displayStream, destinationNumber: `${this.extension}-screen`, remoteCallerName, remoteCallerNumber: `${remoteCallerNumber}-screen`, callerName: `${callerName} (Screen)`, callerNumber: `${callerNumber} (Screen)` }, opts);
            this.screenShare = new Call(this.session, options);
            this.screenShare.invite();
            return this.screenShare;
        });
    }
    stopScreenShare() {
        if (this.screenShare instanceof Call) {
            this.screenShare.hangup();
        }
    }
    setAudioOutDevice(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.speakerId = deviceId;
            const { remoteElement, speakerId } = this.options;
            if (remoteElement && speakerId) {
                return webrtc_1.setMediaElementSinkId(remoteElement, speakerId);
            }
            return false;
        });
    }
    _finalize() {
        this._stats(false);
        super._finalize();
    }
    _stats(what = true) {
        if (what === false) {
            return clearInterval(this._statsInterval);
        }
        logger_1.default.setLevel(2);
        this._statsInterval = window.setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const stats = yield this.peer.instance.getStats(null);
            let statsOutput = '';
            const invalidReport = ['certificate', 'codec', 'peer-connection', 'stream', 'local-candidate', 'remote-candidate'];
            const invalidStat = ['id', 'type', 'timestamp'];
            stats.forEach(report => {
                if (invalidReport.includes(report.type)) {
                    return;
                }
                statsOutput += `\n${report.type}\n`;
                Object.keys(report).forEach(statName => {
                    if (!invalidStat.includes(statName)) {
                        statsOutput += `\t${statName}: ${report[statName]}\n`;
                    }
                });
            });
            logger_1.default.info(statsOutput);
        }), 2000);
    }
}
exports.default = Call;
