"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../util/logger"));
const constants_1 = require("../util/constants");
const helpers_1 = require("../util/helpers");
const Handler_1 = require("../services/Handler");
const helpers_2 = require("../util/helpers");
let WebSocketClass = typeof WebSocket !== 'undefined' ? WebSocket : null;
exports.setWebSocket = (websocket) => {
    WebSocketClass = websocket;
};
const WS_STATE = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
};
const TIMEOUT_MS = 10 * 1000;
class Connection {
    constructor(session) {
        this.session = session;
        this._wsClient = null;
        this._host = 'wss://relay.signalwire.com';
        this._timers = {};
        this.upDur = null;
        this.downDur = null;
        const { host } = session.options;
        if (host) {
            this._host = helpers_1.checkWebSocketHost(host);
        }
    }
    get connected() {
        return this._wsClient && this._wsClient.readyState === WS_STATE.OPEN;
    }
    get connecting() {
        return this._wsClient && this._wsClient.readyState === WS_STATE.CONNECTING;
    }
    get closing() {
        return this._wsClient && this._wsClient.readyState === WS_STATE.CLOSING;
    }
    get closed() {
        return this._wsClient && this._wsClient.readyState === WS_STATE.CLOSED;
    }
    get isAlive() {
        return this.connecting || this.connected;
    }
    get isDead() {
        return this.closing || this.closed;
    }
    connect() {
        this._wsClient = new WebSocketClass(this._host);
        this._wsClient.onopen = (event) => Handler_1.trigger(constants_1.SwEvent.SocketOpen, event, this.session.uuid);
        this._wsClient.onclose = (event) => Handler_1.trigger(constants_1.SwEvent.SocketClose, event, this.session.uuid);
        this._wsClient.onerror = (event) => Handler_1.trigger(constants_1.SwEvent.SocketError, event, this.session.uuid);
        this._wsClient.onmessage = (event) => {
            const msg = helpers_1.safeParseJson(event.data);
            if (typeof msg === 'string') {
                this._handleStringResponse(msg);
                return;
            }
            this._unsetTimer(msg.id);
            logger_1.default.debug('RECV: \n', JSON.stringify(msg, null, 2), '\n');
            if (!Handler_1.trigger(msg.id, msg)) {
                Handler_1.trigger(constants_1.SwEvent.SocketMessage, msg, this.session.uuid);
            }
        };
    }
    sendRawText(request) {
        this._wsClient.send(request);
    }
    send(bladeObj) {
        const { request } = bladeObj;
        const promise = new Promise((resolve, reject) => {
            if (request.hasOwnProperty('result')) {
                return resolve();
            }
            Handler_1.registerOnce(request.id, (response) => {
                const { result, error } = helpers_1.destructResponse(response);
                return error ? reject(error) : resolve(result);
            });
            this._setTimer(request.id);
        });
        logger_1.default.debug('SEND: \n', JSON.stringify(request, null, 2), '\n');
        this._wsClient.send(JSON.stringify(request));
        return promise;
    }
    close() {
        if (this._wsClient) {
            helpers_2.isFunction(this._wsClient._beginClose) ? this._wsClient._beginClose() : this._wsClient.close();
        }
        this._wsClient = null;
    }
    _unsetTimer(id) {
        clearTimeout(this._timers[id]);
        delete this._timers[id];
    }
    _setTimer(id) {
        this._timers[id] = setTimeout(() => {
            Handler_1.trigger(id, { error: { code: this.session.timeoutErrorCode, message: 'Timeout' } });
            this._unsetTimer(id);
        }, TIMEOUT_MS);
    }
    _handleStringResponse(response) {
        if (/^#SP/.test(response)) {
            switch (response[3]) {
                case 'U':
                    this.upDur = parseInt(response.substring(4));
                    break;
                case 'D':
                    this.downDur = parseInt(response.substring(4));
                    Handler_1.trigger(constants_1.SwEvent.SpeedTest, { upDur: this.upDur, downDur: this.downDur }, this.session.uuid);
                    break;
            }
        }
        else {
            logger_1.default.warn('Unknown message from socket', response);
        }
    }
}
exports.default = Connection;
