"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const logger_1 = __importDefault(require("./util/logger"));
const Connection_1 = __importDefault(require("./services/Connection"));
const Setup_1 = __importDefault(require("./services/Setup"));
const Handler_1 = require("./services/Handler");
const BroadcastHandler_1 = __importDefault(require("./services/BroadcastHandler"));
const constants_1 = require("./util/constants");
const constants_2 = require("./webrtc/constants");
const Blade_1 = require("./messages/Blade");
const helpers_1 = require("./util/helpers");
const storage_1 = require("./util/storage/");
const KEEPALIVE_INTERVAL = 10 * 1000;
class BaseSession {
    constructor(options) {
        this.options = options;
        this.uuid = uuid_1.v4();
        this.sessionid = '';
        this.subscriptions = {};
        this.expiresAt = 0;
        this.signature = null;
        this.relayProtocol = null;
        this.contexts = [];
        this.timeoutErrorCode = -32000;
        this.connection = null;
        this._jwtAuth = false;
        this._doKeepAlive = false;
        this._autoReconnect = true;
        this._idle = false;
        this._executeQueue = [];
        if (!this.validateOptions()) {
            throw new Error('Invalid init options');
        }
        this._onSocketOpen = this._onSocketOpen.bind(this);
        this._onSocketCloseOrError = this._onSocketCloseOrError.bind(this);
        this._onSocketMessage = this._onSocketMessage.bind(this);
        this._handleLoginError = this._handleLoginError.bind(this);
        this._checkTokenExpiration = this._checkTokenExpiration.bind(this);
        this._attachListeners();
        this.connection = new Connection_1.default(this);
    }
    get __logger() {
        return logger_1.default;
    }
    get connected() {
        return this.connection && this.connection.connected;
    }
    get expired() {
        return this.expiresAt && this.expiresAt <= (Date.now() / 1000);
    }
    get reconnectDelay() {
        return helpers_1.randomInt(6, 2) * 1000;
    }
    execute(msg) {
        if (this._idle) {
            return new Promise(resolve => this._executeQueue.push({ resolve, msg }));
        }
        if (!this.connected) {
            return new Promise(resolve => {
                this._executeQueue.push({ resolve, msg });
                this.connect();
            });
        }
        return this.connection.send(msg)
            .catch(error => {
            if (error.code && error.code === this.timeoutErrorCode) {
                this._closeConnection();
            }
            throw error;
        });
    }
    executeRaw(text) {
        if (this._idle) {
            this._executeQueue.push({ msg: text });
            return;
        }
        this.connection.sendRawText(text);
    }
    validateOptions() {
        const { project = false, token = false } = this.options;
        return Boolean(project && token);
    }
    broadcast(params) { }
    subscribe({ protocol, channels, handler }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bs = new Blade_1.Subscription({ command: constants_1.ADD, protocol, channels });
            const result = yield this.execute(bs);
            const { failed_channels = [], subscribe_channels = [] } = result;
            if (failed_channels.length) {
                failed_channels.forEach((channel) => this._removeSubscription(protocol, channel));
            }
            subscribe_channels.forEach((channel) => this._addSubscription(protocol, handler, channel));
            return result;
        });
    }
    unsubscribe({ protocol, channels, handler }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bs = new Blade_1.Subscription({ command: constants_1.REMOVE, protocol, channels });
            return this.execute(bs);
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this._reconnectTimeout);
            this.subscriptions = {};
            this._autoReconnect = false;
            this.relayProtocol = null;
            this._closeConnection();
            yield storage_1.sessionStorage.removeItem(this.signature);
            this._executeQueue = [];
            this._detachListeners();
        });
    }
    on(eventName, callback) {
        Handler_1.register(eventName, callback, this.uuid);
        return this;
    }
    off(eventName, callback) {
        Handler_1.deRegister(eventName, callback, this.uuid);
        return this;
    }
    refreshToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            this.options.token = token;
            try {
                if (this.expired) {
                    yield this.connect();
                }
                else {
                    const br = new Blade_1.Reauthenticate(this.options.project, token, this.sessionid);
                    const response = yield this.execute(br);
                    const { authorization: { expires_at = null } = {} } = response;
                    this.expiresAt = +expires_at || 0;
                }
            }
            catch (error) {
                logger_1.default.error('refreshToken error:', error);
                Handler_1.trigger(constants_1.SwEvent.Error, error, this.uuid, false);
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connection) {
                this.connection = new Connection_1.default(this);
            }
            this._attachListeners();
            if (!this.connection.isAlive) {
                this.connection.connect();
            }
        });
    }
    _handleLoginError(error) {
        Handler_1.trigger(constants_1.SwEvent.Error, error, this.uuid);
    }
    _onSocketOpen() {
        return __awaiter(this, void 0, void 0, function* () {
            this._idle = false;
            const tokenKey = this._jwtAuth ? 'jwt_token' : 'token';
            const { project, token } = this.options;
            const bc = new Blade_1.Connect({ project, [tokenKey]: token }, this.sessionid);
            const response = yield this.execute(bc).catch(this._handleLoginError);
            if (response) {
                this._autoReconnect = true;
                const { sessionid, nodeid, master_nodeid, authorization: { expires_at = null, signature = null } = {} } = response;
                this.expiresAt = +expires_at || 0;
                this.signature = signature;
                this.relayProtocol = yield Setup_1.default(this);
                this._checkTokenExpiration();
                this.sessionid = sessionid;
                this.nodeid = nodeid;
                this.master_nodeid = master_nodeid;
                this._emptyExecuteQueues();
                this._pong = null;
                this._keepAlive();
                Handler_1.trigger(constants_1.SwEvent.Ready, this, this.uuid);
                logger_1.default.info('Session Ready!');
            }
        });
    }
    _onSocketCloseOrError(event) {
        logger_1.default.error(`Socket ${event.type} ${event.message}`);
        if (this.relayProtocol) {
            Handler_1.deRegisterAll(this.relayProtocol);
        }
        for (const sub in this.subscriptions) {
            Handler_1.deRegisterAll(sub);
        }
        this.subscriptions = {};
        this.contexts = [];
        if (this.expired) {
            this._idle = true;
            this._autoReconnect = false;
            this.expiresAt = 0;
        }
        if (this._autoReconnect) {
            this._reconnectTimeout = setTimeout(() => this.connect(), this.reconnectDelay);
        }
    }
    _onSocketMessage(response) {
        const { method, params } = response;
        switch (method) {
            case constants_1.BladeMethod.Broadcast:
                BroadcastHandler_1.default(this, params);
                break;
            case constants_1.BladeMethod.Disconnect:
                this._idle = true;
                break;
        }
    }
    _removeSubscription(protocol, channel) {
        if (!this._existsSubscription(protocol, channel)) {
            return;
        }
        if (channel) {
            delete this.subscriptions[protocol][channel];
            Handler_1.deRegister(protocol, null, channel);
        }
        else {
            delete this.subscriptions[protocol];
            Handler_1.deRegisterAll(protocol);
        }
    }
    _addSubscription(protocol, handler = null, channel) {
        if (this._existsSubscription(protocol, channel)) {
            return;
        }
        if (!this._existsSubscription(protocol)) {
            this.subscriptions[protocol] = {};
        }
        this.subscriptions[protocol][channel] = {};
        if (helpers_1.isFunction(handler)) {
            Handler_1.register(protocol, handler, channel);
        }
    }
    _existsSubscription(protocol, channel) {
        if (this.subscriptions.hasOwnProperty(protocol)) {
            if (!channel || (channel && this.subscriptions[protocol].hasOwnProperty(channel))) {
                return true;
            }
        }
        return false;
    }
    _attachListeners() {
        this._detachListeners();
        this.on(constants_1.SwEvent.SocketOpen, this._onSocketOpen);
        this.on(constants_1.SwEvent.SocketClose, this._onSocketCloseOrError);
        this.on(constants_1.SwEvent.SocketError, this._onSocketCloseOrError);
        this.on(constants_1.SwEvent.SocketMessage, this._onSocketMessage);
    }
    _detachListeners() {
        this.off(constants_1.SwEvent.SocketOpen, this._onSocketOpen);
        this.off(constants_1.SwEvent.SocketClose, this._onSocketCloseOrError);
        this.off(constants_1.SwEvent.SocketError, this._onSocketCloseOrError);
        this.off(constants_1.SwEvent.SocketMessage, this._onSocketMessage);
    }
    _emptyExecuteQueues() {
        this._executeQueue.forEach(({ resolve, msg }) => {
            if (typeof msg === 'string') {
                this.executeRaw(msg);
            }
            else {
                resolve(this.execute(msg));
            }
        });
    }
    _closeConnection() {
        this._idle = true;
        clearTimeout(this._keepAliveTimeout);
        if (this.connection) {
            this.connection.close();
        }
    }
    _checkTokenExpiration() {
        if (!this.expiresAt) {
            return;
        }
        const diff = this.expiresAt - (Date.now() / 1000);
        if (diff <= 60) {
            logger_1.default.warn('Your JWT is going to expire. You should refresh it to keep the session live.');
            Handler_1.trigger(constants_1.SwEvent.Notification, { type: constants_2.NOTIFICATION_TYPE.refreshToken, session: this }, this.uuid, false);
        }
        if (!this.expired) {
            setTimeout(this._checkTokenExpiration, 30 * 1000);
        }
    }
    _keepAlive() {
        if (this._doKeepAlive !== true) {
            return;
        }
        if (this._pong === false) {
            return this._closeConnection();
        }
        this._pong = false;
        this.execute(new Blade_1.Ping())
            .then(() => this._pong = true)
            .catch(() => this._pong = false);
        this._keepAliveTimeout = setTimeout(() => this._keepAlive(), KEEPALIVE_INTERVAL);
    }
    static on(eventName, callback) {
        Handler_1.register(eventName, callback);
    }
    static off(eventName) {
        Handler_1.deRegister(eventName);
    }
    static uuid() {
        return uuid_1.v4();
    }
}
exports.default = BaseSession;
