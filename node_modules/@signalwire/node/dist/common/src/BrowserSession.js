"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("./util/logger"));
const BaseSession_1 = __importDefault(require("./BaseSession"));
const Handler_1 = require("./services/Handler");
const constants_1 = require("./util/constants");
const constants_2 = require("./webrtc/constants");
const helpers_1 = require("./webrtc/helpers");
const helpers_2 = require("./util/helpers");
const Verto_1 = require("./messages/Verto");
const storage_1 = require("./util/storage/");
const webrtc_1 = require("./util/webrtc");
class BrowserSession extends BaseSession_1.default {
    constructor() {
        super(...arguments);
        this.calls = {};
        this.autoRecoverCalls = true;
        this._iceServers = [];
        this._localElement = null;
        this._remoteElement = null;
        this._jwtAuth = true;
        this._devices = {};
        this._audioConstraints = true;
        this._videoConstraints = false;
        this._speaker = null;
    }
    get reconnectDelay() {
        return 1000;
    }
    connect() {
        const _super = Object.create(null, {
            connect: { get: () => super.connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.sessionid = yield storage_1.localStorage.getItem(constants_1.SESSION_ID);
            _super.connect.call(this);
        });
    }
    checkPermissions(audio = true, video = true) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stream = yield helpers_1.getUserMedia({ audio, video });
                webrtc_1.stopStream(stream);
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    logout() {
        this.disconnect();
    }
    disconnect() {
        const _super = Object.create(null, {
            disconnect: { get: () => super.disconnect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(this.calls).forEach(k => this.calls[k].setState(constants_2.State.Purge));
            this.calls = {};
            yield _super.disconnect.call(this);
        });
    }
    speedTest(bytes) {
        return new Promise((resolve, reject) => {
            Handler_1.registerOnce(constants_1.SwEvent.SpeedTest, speedTestResult => {
                const { upDur, downDur } = speedTestResult;
                const upKps = upDur ? (((bytes * 8) / (upDur / 1000)) / 1024) : 0;
                const downKps = downDur ? (((bytes * 8) / (downDur / 1000)) / 1024) : 0;
                resolve({ upDur, downDur, upKps: upKps.toFixed(0), downKps: downKps.toFixed(0) });
            }, this.uuid);
            bytes = Number(bytes);
            if (!bytes) {
                return reject(`Invalid parameter 'bytes': ${bytes}`);
            }
            this.executeRaw(`#SPU ${bytes}`);
            let loops = bytes / 1024;
            if (bytes % 1024) {
                loops++;
            }
            const dots = '.'.repeat(1024);
            for (let i = 0; i < loops; i++) {
                this.executeRaw(`#SPB ${dots}`);
            }
            this.executeRaw('#SPE');
        });
    }
    getDevices() {
        return helpers_1.getDevices().catch(error => {
            Handler_1.trigger(constants_1.SwEvent.MediaError, error, this.uuid);
            return [];
        });
    }
    getVideoDevices() {
        return helpers_1.getDevices(constants_2.DeviceType.Video).catch(error => {
            Handler_1.trigger(constants_1.SwEvent.MediaError, error, this.uuid);
            return [];
        });
    }
    getAudioInDevices() {
        return helpers_1.getDevices(constants_2.DeviceType.AudioIn).catch(error => {
            Handler_1.trigger(constants_1.SwEvent.MediaError, error, this.uuid);
            return [];
        });
    }
    getAudioOutDevices() {
        return helpers_1.getDevices(constants_2.DeviceType.AudioOut).catch(error => {
            Handler_1.trigger(constants_1.SwEvent.MediaError, error, this.uuid);
            return [];
        });
    }
    validateDeviceId(id, label, kind) {
        return helpers_1.assureDeviceId(id, label, kind);
    }
    refreshDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.warn('This method has been deprecated. Use getDevices() instead.');
            const cache = {};
            ['videoinput', 'audioinput', 'audiooutput'].map((kind) => {
                cache[kind] = {};
                Object.defineProperty(cache[kind], 'toArray', {
                    value: function () {
                        return Object.keys(this).map(k => this[k]);
                    }
                });
            });
            const devices = yield this.getDevices();
            devices.forEach((t) => {
                if (cache.hasOwnProperty(t.kind)) {
                    cache[t.kind][t.deviceId] = t;
                }
            });
            this._devices = cache;
            return this.devices;
        });
    }
    get devices() {
        return this._devices || {};
    }
    getDeviceResolutions(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield helpers_1.scanResolutions(deviceId);
            }
            catch (error) {
                throw error;
            }
        });
    }
    get videoDevices() {
        logger_1.default.warn('This property has been deprecated. Use getVideoDevices() instead.');
        return this._devices.videoinput || {};
    }
    get audioInDevices() {
        logger_1.default.warn('This property has been deprecated. Use getAudioInDevices() instead.');
        return this._devices.audioinput || {};
    }
    get audioOutDevices() {
        logger_1.default.warn('This property has been deprecated. Use getAudioOutDevices() instead.');
        return this._devices.audiooutput || {};
    }
    get mediaConstraints() {
        return { audio: this._audioConstraints, video: this._videoConstraints };
    }
    setAudioSettings(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            const { micId, micLabel } = settings, constraints = __rest(settings, ["micId", "micLabel"]);
            helpers_1.removeUnsupportedConstraints(constraints);
            this._audioConstraints = yield helpers_1.checkDeviceIdConstraints(micId, micLabel, 'audioinput', constraints);
            this.micId = micId;
            this.micLabel = micLabel;
            return this._audioConstraints;
        });
    }
    disableMicrophone() {
        this._audioConstraints = false;
    }
    enableMicrophone() {
        this._audioConstraints = true;
    }
    setVideoSettings(settings) {
        return __awaiter(this, void 0, void 0, function* () {
            const { camId, camLabel } = settings, constraints = __rest(settings, ["camId", "camLabel"]);
            helpers_1.removeUnsupportedConstraints(constraints);
            this._videoConstraints = yield helpers_1.checkDeviceIdConstraints(camId, camLabel, 'videoinput', constraints);
            this.camId = camId;
            this.camLabel = camLabel;
            return this._videoConstraints;
        });
    }
    disableWebcam() {
        this._videoConstraints = false;
    }
    enableWebcam() {
        this._videoConstraints = true;
    }
    set iceServers(servers) {
        if (typeof servers === 'boolean') {
            this._iceServers = servers ? [{ urls: ['stun:stun.l.google.com:19302'] }] : [];
        }
        else {
            this._iceServers = servers;
        }
    }
    get iceServers() {
        return this._iceServers;
    }
    set speaker(deviceId) {
        this._speaker = deviceId;
    }
    get speaker() {
        return this._speaker;
    }
    set localElement(tag) {
        this._localElement = helpers_2.findElementByType(tag);
    }
    get localElement() {
        return this._localElement;
    }
    set remoteElement(tag) {
        this._remoteElement = helpers_2.findElementByType(tag);
    }
    get remoteElement() {
        return this._remoteElement;
    }
    vertoBroadcast({ nodeId, channel: eventChannel = '', data }) {
        if (!eventChannel) {
            throw new Error('Invalid channel for broadcast: ' + eventChannel);
        }
        const msg = new Verto_1.Broadcast({ sessid: this.sessionid, eventChannel, data });
        if (nodeId) {
            msg.targetNodeId = nodeId;
        }
        this.execute(msg).catch(error => error);
    }
    vertoSubscribe({ nodeId, channels: eventChannel = [], handler }) {
        return __awaiter(this, void 0, void 0, function* () {
            eventChannel = eventChannel.filter(channel => channel && !this._existsSubscription(this.relayProtocol, channel));
            if (!eventChannel.length) {
                return {};
            }
            const msg = new Verto_1.Subscribe({ sessid: this.sessionid, eventChannel });
            if (nodeId) {
                msg.targetNodeId = nodeId;
            }
            const response = yield this.execute(msg);
            const { unauthorized = [], subscribed = [] } = helpers_1.destructSubscribeResponse(response);
            if (unauthorized.length) {
                unauthorized.forEach(channel => this._removeSubscription(this.relayProtocol, channel));
            }
            subscribed.forEach(channel => this._addSubscription(this.relayProtocol, handler, channel));
            return response;
        });
    }
    vertoUnsubscribe({ nodeId, channels: eventChannel = [] }) {
        return __awaiter(this, void 0, void 0, function* () {
            eventChannel = eventChannel.filter(channel => channel && this._existsSubscription(this.relayProtocol, channel));
            if (!eventChannel.length) {
                return {};
            }
            const msg = new Verto_1.Unsubscribe({ sessid: this.sessionid, eventChannel });
            if (nodeId) {
                msg.targetNodeId = nodeId;
            }
            const response = yield this.execute(msg);
            const { unsubscribed = [], notSubscribed = [] } = helpers_1.destructSubscribeResponse(response);
            unsubscribed.forEach(channel => this._removeSubscription(this.relayProtocol, channel));
            notSubscribed.forEach(channel => this._removeSubscription(this.relayProtocol, channel));
            return response;
        });
    }
}
exports.default = BrowserSession;
