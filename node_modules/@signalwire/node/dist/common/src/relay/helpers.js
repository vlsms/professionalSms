"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const relay_1 = require("../util/constants/relay");
const helpers_1 = require("../util/helpers");
exports.prepareConnectParams = (params, callDevice) => {
    let devices = [];
    let ringback = null;
    if (params.length === 1 && _isICallingConnectParams(params[0])) {
        devices = params[0].devices;
        if (params[0].ringback) {
            ringback = _destructCallingPlay(params[0].ringback);
        }
    }
    else {
        params.forEach(p => {
            if (!_isICallingConnectParams(p)) {
                devices.push(p);
            }
        });
    }
    return [
        exports.reduceConnectParams(devices, callDevice),
        ringback
    ];
};
exports.reduceConnectParams = (peers, callDevice) => {
    let defaultFromNumber;
    let defaultTimeout;
    if (callDevice.type === 'phone') {
        defaultFromNumber = callDevice.params.from_number;
        defaultTimeout = callDevice.params.timeout;
    }
    else if (callDevice.type === 'sip') {
        defaultFromNumber = callDevice.params.from;
    }
    const { devices } = peers.reduce(_reducer, {
        devices: [],
        nested: false,
        options: { defaultFromNumber, defaultTimeout, validate: false }
    });
    return devices;
};
exports.prepareRecordParams = (params) => {
    const { audio = {}, type } = params, flattenedParams = __rest(params, ["audio", "type"]);
    return { audio: Object.assign(Object.assign({}, audio), flattenedParams) };
};
const _destructCallingPlay = (media) => {
    if ('params' in media) {
        const { type, params = {} } = media, flattenedParams = __rest(media, ["type", "params"]);
        return { type, params: Object.assign(Object.assign({}, params), flattenedParams) };
    }
    else {
        const { type } = media, params = __rest(media, ["type"]);
        return { type, params };
    }
};
exports.preparePlayParams = (params) => {
    let mediaList = [];
    let volume = 0;
    if (params.length === 1 && _isICallingPlayParams(params[0])) {
        mediaList = params[0].media;
        volume = params[0].volume || 0;
    }
    else {
        params.forEach(p => {
            if (!_isICallingPlayParams(p)) {
                mediaList.push(p);
            }
        });
    }
    return [
        mediaList.map(_destructCallingPlay),
        volume
    ];
};
exports.preparePlayAudioParams = (params) => {
    if (typeof (params) === 'string') {
        return [params, 0];
    }
    const { url, volume = 0 } = params;
    return [url, volume];
};
exports.preparePromptParams = (params, mediaList = []) => {
    const collect = {};
    const { initial_timeout, partial_results, type, media = mediaList, volume = 0 } = params;
    let { digits, speech } = params;
    if (!digits) {
        const { digits_max: max, digits_terminators: terminators, digits_timeout: digit_timeout } = params;
        digits = helpers_1.deepCopy({ max, terminators, digit_timeout });
    }
    if (!speech) {
        const { end_silence_timeout, speech_timeout, speech_language: language, speech_hints: hints } = params;
        speech = helpers_1.deepCopy({ end_silence_timeout, speech_timeout, language, hints });
    }
    if (initial_timeout) {
        collect.initial_timeout = initial_timeout;
    }
    if (partial_results) {
        collect.partial_results = partial_results;
    }
    if (!helpers_1.objEmpty(digits) || (type === 'digits' || type === 'both')) {
        collect.digits = digits;
    }
    if (!helpers_1.objEmpty(speech) || (type === 'speech' || type === 'both')) {
        collect.speech = speech;
    }
    const [play, __volume] = exports.preparePlayParams(media);
    return [collect, play, volume];
};
exports.preparePromptAudioParams = (params, urlDeprecated = '') => {
    const { url = urlDeprecated } = params, flattenedParams = __rest(params, ["url"]);
    flattenedParams.media = [
        { type: relay_1.CallPlayType.Audio, params: { url } }
    ];
    return flattenedParams;
};
exports.preparePromptTTSParams = (params, ttsOptions = { text: '' }) => {
    const { text, gender, language } = params, flattenedParams = __rest(params, ["text", "gender", "language"]);
    if (text) {
        ttsOptions.text = text;
    }
    if (gender) {
        ttsOptions.gender = gender;
    }
    if (language) {
        ttsOptions.language = language;
    }
    flattenedParams.media = [
        { type: relay_1.CallPlayType.TTS, params: ttsOptions }
    ];
    return flattenedParams;
};
exports.preparePromptRingtoneParams = (params) => {
    const { name, duration } = params, flattenedParams = __rest(params, ["name", "duration"]);
    const mediaParams = { name };
    if (duration) {
        mediaParams.duration = duration;
    }
    flattenedParams.media = [
        { type: relay_1.CallPlayType.Ringtone, params: mediaParams }
    ];
    return flattenedParams;
};
exports.prepareTapParams = (params, device = {}) => {
    const tap = { type: 'audio', params: {} };
    if ('direction' in params) {
        tap.params.direction = params.direction;
    }
    else if ('audio_direction' in params) {
        tap.params.direction = params.audio_direction;
    }
    let targetType = '';
    if ('target_type' in params) {
        targetType = params.target_type;
    }
    const { type = targetType } = device, deviceParams = __rest(device, ["type"]);
    const newDevice = { type, params: {} };
    if ('target_addr' in params) {
        deviceParams.addr = params.target_addr;
    }
    if ('target_port' in params) {
        deviceParams.port = params.target_port;
    }
    if ('target_ptime' in params) {
        deviceParams.ptime = params.target_ptime;
    }
    if ('target_uri' in params) {
        deviceParams.uri = params.target_uri;
    }
    if ('rate' in params) {
        deviceParams.rate = params.rate;
    }
    if ('codec' in params) {
        deviceParams.codec = params.codec;
    }
    newDevice.params = deviceParams;
    return { tap, device: newDevice };
};
exports.prepareDialDevices = (params) => {
    return params.reduce(_reducer, { devices: [], nested: false, options: { validate: true } }).devices;
};
exports.prepareDevice = (params, defaultFromNumber = null, originalCallTimeout = null, validate) => {
    const { type, from = defaultFromNumber, to, timeout = originalCallTimeout !== null && originalCallTimeout !== void 0 ? originalCallTimeout : relay_1.DEFAULT_CALL_TIMEOUT } = params;
    if (validate) {
        if (!type || !to || !timeout || !from) {
            throw new TypeError(`Invalid parameters to create a new Call.`);
        }
    }
    let device;
    if (params.type === 'phone') {
        device = { type: params.type, params: { from_number: from, to_number: to, timeout } };
    }
    else if (params.type === 'sip') {
        const { headers, codecs, webrtc_media } = params;
        device = { type: params.type, params: { from, to } };
        if (timeout) {
            device.params.timeout = timeout;
        }
        if (codecs) {
            device.params.codecs = codecs;
        }
        if (webrtc_media) {
            device.params.webrtc_media = webrtc_media;
        }
        if (headers instanceof Array && headers.length) {
            device.params.headers = headers;
        }
    }
    return device;
};
exports.isIDialCallParams = (params) => {
    return params.devices !== undefined;
};
const _isICallingPlayParams = (params) => {
    return params.media !== undefined;
};
const _isICallingConnectParams = (params) => {
    return params.devices !== undefined;
};
const _reducer = (accumulator, peer) => {
    var _a;
    let tmp = null;
    if (peer instanceof Array) {
        const nestedAccumulator = { devices: [], nested: true };
        if (accumulator.options) {
            nestedAccumulator.options = accumulator.options;
        }
        tmp = peer.reduce(_reducer, nestedAccumulator).devices;
    }
    else if (typeof peer === 'object') {
        const { defaultFromNumber, defaultTimeout, validate } = (_a = accumulator.options) !== null && _a !== void 0 ? _a : {};
        tmp = exports.prepareDevice(peer, defaultFromNumber, defaultTimeout, validate);
    }
    if (tmp) {
        const castArray = accumulator.nested || peer instanceof Array;
        castArray ? accumulator.devices.push(tmp) : accumulator.devices.push([tmp]);
    }
    return accumulator;
};
