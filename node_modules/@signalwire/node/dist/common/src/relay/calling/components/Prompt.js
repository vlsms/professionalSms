"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Controllable_1 = require("./Controllable");
const relay_1 = require("../../../util/constants/relay");
const Event_1 = __importDefault(require("../Event"));
class Prompt extends Controllable_1.Controllable {
    constructor(call, collect, play, volumeValue = 0) {
        super(call);
        this.call = call;
        this.collect = collect;
        this.play = play;
        this.volumeValue = volumeValue;
        this.eventType = relay_1.CallNotification.Collect;
        this.method = relay_1.CallMethod.PlayAndCollect;
        this.controlId = this.controlId;
    }
    get payload() {
        const tmp = {
            node_id: this.call.nodeId,
            call_id: this.call.id,
            control_id: this.controlId,
            play: this.play,
            collect: this.collect
        };
        if (this.volumeValue != 0) {
            tmp.volume = +this.volumeValue;
        }
        return tmp;
    }
    notificationHandler(params) {
        this.completed = true;
        const { result } = params;
        this.type = result.type;
        this.event = new Event_1.default(this.type, result);
        switch (this.type) {
            case relay_1.CallPromptState.Digit:
                this.state = 'successful';
                this.successful = true;
                this.input = result.params.digits;
                this.terminator = result.params.terminator;
                break;
            case relay_1.CallPromptState.Speech:
                this.state = 'successful';
                this.successful = true;
                this.input = result.params.text;
                this.confidence = result.params.confidence;
                break;
            default:
                this.state = this.type;
                this.successful = false;
        }
        if (this._hasBlocker() && this._eventsToWait.includes(this.type)) {
            this.blocker.resolve();
        }
    }
}
exports.Prompt = Prompt;
