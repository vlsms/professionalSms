"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Controllable_1 = require("./Controllable");
const relay_1 = require("../../../util/constants/relay");
const Event_1 = __importDefault(require("../Event"));
const _finishedEvents = [relay_1.CallDetectState.Error, relay_1.CallDetectState.Finished];
const _machineStateEvents = [relay_1.CallDetectState.Ready, relay_1.CallDetectState.NotReady];
class Detect extends Controllable_1.Controllable {
    constructor(call, _detect, _timeout = null, _waitForBeep = false) {
        super(call);
        this.call = call;
        this._detect = _detect;
        this._timeout = _timeout;
        this._waitForBeep = _waitForBeep;
        this.eventType = relay_1.CallNotification.Detect;
        this.method = relay_1.CallMethod.Detect;
        this.controlId = this.controlId;
        this._events = [];
        this._waitingForReady = false;
    }
    get payload() {
        const { params } = this._detect;
        this._detect.params = params || {};
        const payload = {
            node_id: this.call.nodeId,
            call_id: this.call.id,
            control_id: this.controlId,
            detect: this._detect
        };
        if (this._timeout) {
            payload.timeout = this._timeout;
        }
        return payload;
    }
    notificationHandler(params) {
        const { detect } = params;
        const { type, params: { event } } = detect;
        this.type = type;
        this.state = event;
        if (_finishedEvents.includes(event)) {
            return this._complete(detect);
        }
        if (!this._hasBlocker()) {
            this._events.push(this.state);
            return;
        }
        if (this.type === relay_1.CallDetectType.Digit) {
            return this._complete(detect);
        }
        if (this._waitingForReady) {
            if (event === relay_1.CallDetectState.Ready) {
                return this._complete(detect);
            }
            return;
        }
        if (this._waitForBeep && event === relay_1.CallDetectState.Machine) {
            this._waitingForReady = true;
            return;
        }
        if (this._eventsToWait.includes(this.state)) {
            return this._complete(detect);
        }
    }
    _complete(detect) {
        this.completed = true;
        this.event = new Event_1.default(this.state, detect);
        if (this._hasBlocker()) {
            this.successful = !_finishedEvents.includes(this.state);
            if (_machineStateEvents.includes(this.state)) {
                this.result = relay_1.CallDetectState.Machine;
            }
            else if (this.successful) {
                this.result = this.state;
            }
            this.blocker.resolve();
        }
        else {
            this.result = this._events.join(',');
            this.successful = this.state !== relay_1.CallDetectState.Error;
        }
    }
}
exports.Detect = Detect;
